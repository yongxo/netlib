
#include "CTcpSocket.h"
CTcpSocket::CTcpSocket(const CSocket* pstSocket)
		: CSocket(pstSocket)
{
}


CTcpSocket::CTcpSocket(const CInetAddress& stInetAddr, tcport_t tPort)
		: CSocket(PF_INET, SOCK_STREAM)
{
	Bind(stInetAddr, tPort);
	m_eState = S_BOUND;
}

/*
CTcpSocket::CTcpSocket(const CUnixAddress& stUnixAddr)
		: CSocket(PF_LOCAL, SOCK_STREAM)
{
	Bind(stUnixAddr);
	m_eState = S_BOUND;
}*/


void CTcpSocket::Open(int iBackLog)
{
	Listen(iBackLog);
}


bool CTcpSocket::Open(const CInetAddress& stInetAddr, tcport_t tPort)
{
	struct sockaddr_in stSockAddr;
	memset(&stSockAddr, 0, sizeof(stSockAddr));
	stSockAddr.sin_family = AF_INET;
	stSockAddr.sin_port = htons(tPort);
	stSockAddr.sin_addr = stInetAddr.GetAddress();
	if (connect(m_iSocket, (struct sockaddr*)&stSockAddr, sizeof(stSockAddr)) < 0)
	{
		if ( (m_bBlock && errno == EINTR) || (!m_bBlock && errno == EINPROGRESS) )
		{
			m_eState = S_CONNECTING;
			return false;
		}
			
		throw CSocketException(strerror(errno), __FILE__, __LINE__);
	}

	m_eState = S_CONNECTED;	
	return true;
}

#if 0
bool CTcpSocket::Open(const CUnixAddress& stUnixAddr)
{
	struct sockaddr_un stSockAddr;
	memset(&stSockAddr, 0, sizeof(stSockAddr));
	stSockAddr.sun_family = AF_LOCAL;
	strcpy(stSockAddr.sun_path, stUnixAddr.path());
	if (connect(m_iSocket, (struct sockaddr*)&stSockAddr, sizeof(stSockAddr)) < 0)
	{
		if ( (m_bBlock && errno == EINTR) || (!m_bBlock && errno == EINPROGRESS) )
		{
			m_eState = S_CONNECTING;
			return false;
		}
			
		throw CSocketException(strerror(errno), __FILE__, __LINE__);
	}

	m_eState = S_CONNECTED;	
	return true;
}
#endif

bool CTcpSocket::CheckOpen(long lSec, long lUSec)
{
	fd_set rset, wset;
	FD_ZERO(&rset);
	FD_SET(m_iSocket, &rset);
	FD_ZERO(&wset);
	FD_SET(m_iSocket, &wset);

	while (true)
	{
		struct timeval stTimeVal;
		stTimeVal.tv_sec = lSec;
		stTimeVal.tv_usec = lUSec;	
		
		int i = 0;	
		i = select(m_iSocket + 1, &rset, &wset, NULL, (lSec == 0 && lUSec == 0) ? NULL : &stTimeVal);
		if (i == 0)	//timeout
			return false;
		
		if (i < 0)
		{
			if (errno == EINTR)
			{
				if (OnCheckOpenIntr())
					continue;
				else
					return false;
			}
				
			throw CSocketException(strerror(errno), __FILE__, __LINE__);
		}
		
		if (FD_ISSET(m_iSocket, &rset) || FD_ISSET(m_iSocket, &wset))
		{
			socklen_t tLen = sizeof(errno);
			if (getsockopt(m_iSocket, SOL_SOCKET, SO_ERROR, &errno, &tLen) < 0	//solaris < 0 when error occurs
					|| errno < 0)
				throw CSocketException(strerror(errno), __FILE__, __LINE__);
				
			m_eState = S_CONNECTED;
			return true;
		}
		
		throw CSocketException("unknown error occurs", __FILE__, __LINE__);
	}
}


bool CTcpSocket::Accept(CTcpStream* pstTcpStream)
{
	if (pstTcpStream->m_iSocket >= 0)
	{
		if (pstTcpStream->m_iBufSize > 0)
			pstTcpStream->sync();
			
		pstTcpStream->clear();
//		pstTcpStream->setb(pstTcpStream->m_pchGetBuf, pstTcpStream->m_pchGetBuf + pstTcpStream->m_iBufSize, 0);
		pstTcpStream->setg(pstTcpStream->m_pchGetBuf, pstTcpStream->m_pchGetBuf + pstTcpStream->m_iBufSize, pstTcpStream->m_pchGetBuf + pstTcpStream->m_iBufSize);
		pstTcpStream->setp(pstTcpStream->m_pchPutBuf, pstTcpStream->m_pchPutBuf + pstTcpStream->m_iBufSize);
		pstTcpStream->End();
	}
	
	struct sockaddr_in stInetSockAddr;
	struct sockaddr_un stUnixSockAddr;
	socklen_t tSockLen;	
	sockaddr* pstSockAddr;
	switch (m_iDomain)
	{
		case PF_INET:
			pstSockAddr = (sockaddr*)&stInetSockAddr;
			tSockLen = sizeof(stInetSockAddr);
			break;
				
		case PF_LOCAL:
			pstSockAddr = (sockaddr*)&stUnixSockAddr;
			tSockLen = sizeof(stUnixSockAddr);
			break;
			
		default:
			throw CSocketException("unknown domain", __FILE__, __LINE__);
	}	
		
	while (true)
	{
		int i = accept(m_iSocket, pstSockAddr, &tSockLen);
		if (i < 0)
		{
			if (m_bBlock && errno == EINTR)
			{
				if (OnAcceptIntr())
					continue;
				else
					return false;
			}
				
			if ( (!m_bBlock) && (errno == EWOULDBLOCK
#ifdef ECONNABORTED
					|| errno == ECONNABORTED
#endif
#ifdef EPROTO
					|| errno == EPROTO
#endif
					) )
				return false;
				
			throw CSocketException(strerror(errno), __FILE__, __LINE__);
		}

		switch (m_iDomain)
		{
			case PF_INET:
				if (!OnAccept(stInetSockAddr.sin_addr, ntohs(stInetSockAddr.sin_port)))
				{
					close(i);
					return false;
				}			
				break;
				
			case PF_LOCAL:
				if (!OnAccept(stUnixSockAddr.sun_path))
				{
					close(i);
					return false;
				}			
				break;
				
			default:
				throw CSocketException("unknown domain", __FILE__, __LINE__);
		}
		
		pstTcpStream->m_iSocket = i;
		pstTcpStream->SetBlock(m_bBlock);
		pstTcpStream->m_eState = S_CONNECTED;
		pstTcpStream->m_iDomain = m_iDomain;
		return true;
	}
}


void CTcpSocket::Listen(int iBackLog)
{
	if (listen(m_iSocket, iBackLog) < 0)
		throw CSocketException(strerror(errno), __FILE__, __LINE__);
}

/////////////////////////////////////////////////////////////////////////////////////////////////

CTcpStream::CTcpStream(int iBufSize)
		: CTcpSocket(), CStream(iBufSize)
{
}


CTcpStream::CTcpStream(const CSocket* pstSocket, int iBufSize)
		: CTcpSocket(pstSocket), CStream(iBufSize)
{
}


CTcpStream::CTcpStream(const CInetAddress& stInetAddr, tcport_t tPort, int iBufSize)
		: CTcpSocket(stInetAddr, tPort), CStream(iBufSize)
{
}

/*
CTcpStream::CTcpStream(const CUnixAddress& stUnixAddr, int iBufSize)
		: CTcpSocket(stUnixAddr), CStream(iBufSize)
{
}
*/

int CTcpStream::overflow(int ch)
{
	assert(pptr()	&& pbase());
	int iInBuf = pptr() - pbase();
	assert(iInBuf >= 0);
	char* pToWrite = pbase();
	int iTotalSend = 0;
	while (iInBuf > 0)	//because this function will be possibly called by flush
	{
		int iSend = ::write(m_iSocket, pToWrite, iInBuf);
		if (iSend <= 0)
		{
			if (m_bBlock && errno == EINTR)
			{
				if (OnWriteIntr())
					continue;
				else
					return EOF;
			}
			else if (!m_bBlock && errno == EWOULDBLOCK)
			{
				return EOF;
			}
			else
			{
				clear(ios::failbit | rdstate());
				return EOF;
			}
		}
		
		iInBuf -= iSend;
		iTotalSend += iSend;
		pToWrite += iSend;
		if (!m_bBlock)
			break;
	}

	if (iInBuf > 0)
		memmove(pbase(), pbase() + iTotalSend, iInBuf);

	setp(m_pchPutBuf, m_pchPutBuf + m_iBufSize);
	pbump(iInBuf);
	
	if(ch != EOF)
	{
		*pptr() = (char)ch;
		pbump(1);
	}

	return ch;
}


int CTcpStream::underflow()
{
	assert(eback() && gptr() && egptr());
	assert(gptr() <= egptr());
//	if(gptr() < egptr())
//		return (unsigned char)*gptr();

	int iBufLeft = gptr() - eback();
	int iInBuf = egptr() - gptr();
	if (iInBuf > 0)
		memmove(eback(), gptr(), iInBuf);
	
	int iRead;
	while (true)
	{
		iRead = ::read(m_iSocket, eback()+iInBuf, iBufLeft);
		if (iRead < 0)
		{
			if (m_bBlock && errno == EINTR)
			{
				if (OnReadIntr())
					continue;
				else
					return EOF;
			}
			else if (!m_bBlock && errno == EWOULDBLOCK)
			{
				return EOF;
			}
			else
			{
				clear(ios::failbit | rdstate());
				return EOF;
			}
		}
		else if (iRead == 0)
		{
			clear(ios::eofbit | rdstate());
			return EOF;
		}
		
		break;
	}

	if (iRead < iBufLeft)
		memmove(eback()+(iBufLeft-iRead), eback(), iInBuf+iRead);

	setg(eback(), eback()+(iBufLeft-iRead), egptr());
	return (unsigned char)*gptr();
}


