#include "tcpstream.h"

CTcpStream::CTcpStream(int iBufSize)
		: CTcpSocket(), CStream(iBufSize)
{
}


CTcpStream::CTcpStream(const CSocket* pstSocket, int iBufSize)
		: CTcpSocket(pstSocket), CStream(iBufSize)
{
}


CTcpStream::CTcpStream(const CInetAddress& stInetAddr, tcport_t tPort, int iBufSize)
		: CTcpSocket(stInetAddr, tPort), CStream(iBufSize)
{
}

/*
CTcpStream::CTcpStream(const CUnixAddress& stUnixAddr, int iBufSize)
		: CTcpSocket(stUnixAddr), CStream(iBufSize)
{
}
*/

int CTcpStream::overflow(int ch)
{
	assert(pptr()	&& pbase());
	int iInBuf = pptr() - pbase();
	assert(iInBuf >= 0);
	char* pToWrite = pbase();
	int iTotalSend = 0;
	while (iInBuf > 0)	//because this function will be possibly called by flush
	{
		int iSend = ::write(m_iSocket, pToWrite, iInBuf);
		if (iSend <= 0)
		{
			if (m_bBlock && errno == EINTR)
			{
				if (OnWriteIntr())
					continue;
				else
					return EOF;
			}
			else if (!m_bBlock && errno == EWOULDBLOCK)
			{
				return EOF;
			}
			else
			{
				clear(ios::failbit | rdstate());
				return EOF;
			}
		}
		
		iInBuf -= iSend;
		iTotalSend += iSend;
		pToWrite += iSend;
		if (!m_bBlock)
			break;
	}

	if (iInBuf > 0)
		memmove(pbase(), pbase() + iTotalSend, iInBuf);

	setp(m_pchPutBuf, m_pchPutBuf + m_iBufSize);
	pbump(iInBuf);
	
	if(ch != EOF)
	{
		*pptr() = (char)ch;
		pbump(1);
	}

	return ch;
}


int CTcpStream::underflow()
{
	assert(eback() && gptr() && egptr());
	assert(gptr() <= egptr());
//	if(gptr() < egptr())
//		return (unsigned char)*gptr();

	int iBufLeft = gptr() - eback();
	int iInBuf = egptr() - gptr();
	if (iInBuf > 0)
		memmove(eback(), gptr(), iInBuf);
	
	int iRead;
	while (true)
	{
		iRead = ::read(m_iSocket, eback()+iInBuf, iBufLeft);
		if (iRead < 0)
		{
			if (m_bBlock && errno == EINTR)
			{
				if (OnReadIntr())
					continue;
				else
					return EOF;
			}
			else if (!m_bBlock && errno == EWOULDBLOCK)
			{
				return EOF;
			}
			else
			{
				clear(ios::failbit | rdstate());
				return EOF;
			}
		}
		else if (iRead == 0)
		{
			clear(ios::eofbit | rdstate());
			return EOF;
		}
		
		break;
	}

	if (iRead < iBufLeft)
		memmove(eback()+(iBufLeft-iRead), eback(), iInBuf+iRead);

	setg(eback(), eback()+(iBufLeft-iRead), egptr());
	return (unsigned char)*gptr();
}

